<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Galactic Directory â€” Sentinel Edition</title>
<meta name="description" content="Self-improving, AI-enhanced directory for the Planetary Restoration Archive with constellation visuals, gamification, and intelligent metadata management.">
<!--
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘  ZERO-HARM / ANTI-INVERSION NOTICE                                    â•‘
  â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  â•‘  This tool is designed for peaceful exploration of planetary          â•‘
  â•‘  restoration resources. It is NOT intended for:                       â•‘
  â•‘  â€¢ Surveillance, tracking, or profiling                               â•‘
  â•‘  â€¢ Weaponization or harmful applications                              â•‘
  â•‘  â€¢ Exploitation of user data                                          â•‘
  â•‘                                                                        â•‘
  â•‘  AI Assistant: Uses Claude API for metadata enhancement only.         â•‘
  â•‘  All data stored locally (IndexedDB). No external tracking.           â•‘
  â•‘  Open source spirit. License: MIT-style respect.                      â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-->
<style>
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: CSS Variables & Theme System
     PURPOSE: Centralized design tokens with dark mode support
     HOW TO USE: Modify values in :root{} to change entire palette
     EXPECTED OUTCOME: Consistent, accessible visual system
     FUTURE EXPANSION: "Add light mode toggle with prefers-color-scheme"
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  :root{
    --bg:#070b14; --bg2:#0b1324; --panel:#0f1d36; --ink:#eaf1ff; --muted:#9bb0cc;
    --accent:#65b3ff; --accent2:#4ee0a1; --warn:#ffb84d; --danger:#ff6b6b; --glow:#8ad7ff;
    --good:#3bd19b; --sentinel:#7cd2ff; --peace:#7fffd4; --corrupt:#ff7f9c; --dash:#ffd166;
    --success:#4ade80; --info:#60a5fa;
  }
  
  *{box-sizing:border-box; margin:0; padding:0}
  html,body{height:100%; scroll-behavior:smooth}
  body{
    color:var(--ink); 
    background:radial-gradient(1200px 800px at 70% -10%,#12203c 0%,transparent 60%), 
               linear-gradient(180deg,var(--bg),var(--bg2) 60%,#060912);
    font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overflow-x:hidden;
  }
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Parallax Background System
     PURPOSE: Layered star field and constellation effects with scroll morphing
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  #stars,#constellations{position:fixed; inset:0; z-index:-2; pointer-events:none}
  #constellations{z-index:-1}
  .parallax{transform:translateZ(0); will-change:transform}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Header & Navigation
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  header{
    position:sticky; top:0; z-index:100; backdrop-filter:saturate(120%) blur(8px);
    background:linear-gradient(180deg,rgba(11,19,36,.95),rgba(11,19,36,.7));
    border-bottom:1px solid #1b2c4d; box-shadow:0 4px 20px rgba(0,0,0,.3);
  }
  .wrap{max-width:1100px; margin:0 auto; padding:16px}
  h1{margin:0 0 6px; font-size:22px; letter-spacing:.4px; color:var(--accent)}
  .sub{color:var(--muted); font-size:13px; line-height:1.4}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: HUD & Gamification
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .hud{display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:10px}
  .chip{background:#0a152a; border:1px solid #203353; padding:8px 10px; border-radius:999px; display:flex; gap:8px; align-items:center; white-space:nowrap}
  .xpbar{height:10px; width:220px; border-radius:999px; background:#0a152a; border:1px solid #1c2d4d; overflow:hidden}
  .xpfill{height:100%; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent2)); box-shadow:0 0 14px var(--glow) inset; transition:width .6s cubic-bezier(.4,0,.2,1)}
  .badge{padding:3px 9px; border-radius:999px; font-size:11px; border:1px solid; opacity:.9; font-weight:500}
  .b-sentinel{border-color:var(--sentinel); color:var(--sentinel); background:rgba(124,210,255,.05)}
  .b-peace{border-color:var(--peace); color:var(--peace); background:rgba(127,255,212,.05)}
  .b-corrupt{border-color:var(--corrupt); color:var(--corrupt); background:rgba(255,127,156,.05)}
  .b-dash{border-color:var(--dash); color:var(--dash); background:rgba(255,209,102,.05)}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Controls & Inputs
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .controls{display:flex; gap:10px; margin-top:10px; flex-wrap:wrap}
  input[type="search"],input[type="text"],textarea{
    flex:1 1 320px; background:#0a152a; color:var(--ink); border:1px solid #1f304f; 
    border-radius:10px; padding:10px 12px; outline:none; font-family:inherit; font-size:14px;
  }
  input:focus,textarea:focus{border-color:#2a4577; box-shadow:0 0 0 3px rgba(42,69,119,.2)}
  select,button{
    background:#0a152a; color:var(--ink); border:1px solid #203353; border-radius:10px; 
    padding:10px 12px; cursor:pointer; font-family:inherit; font-size:14px; transition:all .2s ease;
  }
  button:hover:not(:disabled),select:hover{border-color:#2a4577; background:#0d1a30}
  button:active:not(:disabled){transform:translateY(1px)}
  button:disabled{opacity:.5; cursor:not-allowed}
  button.primary{background:var(--accent); border-color:var(--accent); color:#000; font-weight:600}
  button.primary:hover:not(:disabled){background:#7ac2ff}
  button.danger{border-color:var(--danger); color:var(--danger)}
  button.danger:hover:not(:disabled){background:rgba(255,107,107,.1)}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Main Content Grid
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  main{max-width:1200px; margin:18px auto 80px; padding:0 16px}
  .grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(280px,1fr)); gap:14px}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Directory Cards
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .card{
    background:linear-gradient(180deg,#0c1730,#0c1528);
    border:1px solid #1a2a49; border-radius:16px; padding:14px; position:relative; overflow:hidden;
    transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
  }
  .card:hover{transform:translateY(-2px); box-shadow:0 10px 30px rgba(80,160,255,.08); border-color:#2a4577}
  .card.loading{opacity:.6; pointer-events:none}
  .card.enhanced{border-color:#4ee0a1; box-shadow:0 0 0 1px rgba(78,224,161,.2) inset}
  .title{font-weight:600; color:#eaf1ff; margin:2px 0 6px; word-break:break-word; font-size:16px}
  .path{color:#9ab0cb; font-size:12px; font-family:Consolas,Monaco,monospace; margin-bottom:6px}
  .description{color:#b8cce0; font-size:13px; line-height:1.5; margin:8px 0; display:none}
  .card.enhanced .description{display:block}
  .tags{margin-top:8px; display:flex; gap:6px; flex-wrap:wrap}
  .cta{margin-top:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .cta a,.cta button{
    text-decoration:none; padding:8px 10px; border-radius:10px; border:1px solid #23406f; 
    background:#0a152a; color:#dff2ff; font-size:13px; display:inline-flex; align-items:center; gap:4px;
  }
  .cta a:hover,.cta button:hover{border-color:#3a63a4; background:#0d1a30}
  .glow-ring{position:absolute; inset:auto -20% -60% -20%; height:140px; filter:blur(30px); background:radial-gradient(220px 40px at 50% 0,rgba(120,210,255,.18),transparent 60%)}
  .special{border-color:#2a6fff; box-shadow:0 0 0 1px rgba(86,160,255,.25) inset}
  .special .title{color:#a5d4ff}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: AI Assistant Panel
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .ai-panel{
    position:fixed; bottom:20px; right:20px; z-index:200; width:400px; max-width:calc(100vw - 40px);
    background:linear-gradient(180deg,#0f1d36,#0c1528); border:1px solid #2a4577; border-radius:16px;
    box-shadow:0 20px 60px rgba(0,0,0,.5); transform:translateY(calc(100% + 20px)); transition:transform .3s ease;
  }
  .ai-panel.open{transform:translateY(0)}
  .ai-header{padding:14px 16px; border-bottom:1px solid #1a2a49; display:flex; justify-content:space-between; align-items:center}
  .ai-header h3{font-size:15px; color:var(--accent2); display:flex; align-items:center; gap:8px}
  .ai-close{background:transparent; border:none; color:var(--muted); font-size:20px; padding:0; width:24px; height:24px}
  .ai-body{padding:16px; max-height:400px; overflow-y:auto}
  .ai-message{margin-bottom:12px; padding:10px 12px; border-radius:10px; font-size:13px; line-height:1.5}
  .ai-message.user{background:#1a2a49; color:var(--ink); margin-left:20px}
  .ai-message.assistant{background:rgba(78,224,161,.08); color:#e0f2f1; margin-right:20px; border-left:2px solid var(--accent2)}
  .ai-message.system{background:rgba(255,184,77,.08); color:#ffd699; font-style:italic; text-align:center; font-size:12px}
  .ai-input-wrap{padding:12px 16px; border-top:1px solid #1a2a49; display:flex; gap:8px}
  .ai-input-wrap input{flex:1; min-width:0}
  .ai-fab{
    position:fixed; bottom:20px; right:20px; z-index:199; width:56px; height:56px; border-radius:50%;
    background:linear-gradient(135deg,var(--accent),var(--accent2)); border:none; color:#000;
    font-size:24px; cursor:pointer; box-shadow:0 8px 20px rgba(101,179,255,.4);
    transition:transform .2s ease, box-shadow .2s ease;
  }
  .ai-fab:hover{transform:scale(1.05); box-shadow:0 12px 30px rgba(101,179,255,.6)}
  .ai-fab.hidden{display:none}
  .pulse{animation:pulse 2s ease-in-out infinite}
  @keyframes pulse{0%,100%{box-shadow:0 8px 20px rgba(101,179,255,.4)} 50%{box-shadow:0 8px 30px rgba(101,179,255,.8)}}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Animated Spaceships
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .ship{
    position:fixed; width:30px; height:30px; pointer-events:none; opacity:.8; z-index:0; 
    filter:drop-shadow(0 0 6px rgba(130,200,255,.6))
  }
  @keyframes patrolX{0%{transform:translateX(-10vw)} 100%{transform:translateX(110vw)}}
  @keyframes patrolY{0%{transform:translateY(0)} 50%{transform:translateY(8px)} 100%{transform:translateY(0)}}
  .ship path{stroke:#a7ddff; fill:none; stroke-width:1.2}
  .ship:nth-child(1){top:12vh; left:-10vw; animation:patrolX 42s linear infinite, patrolY 6s ease-in-out infinite}
  .ship:nth-child(2){top:32vh; left:-15vw; animation:patrolX 60s linear infinite reverse, patrolY 8s ease-in-out infinite}
  .ship:nth-child(3){top:68vh; left:-20vw; animation:patrolX 55s linear infinite, patrolY 7s ease-in-out infinite}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Collapsible Categories
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  details.category{background:linear-gradient(180deg,#0b152c,#0b1426); border:1px solid #1a2a49; border-radius:16px; padding:12px 14px; margin:14px 0}
  details>summary{cursor:pointer; list-style:none; user-select:none; font-weight:600; color:#bdddff; display:flex; align-items:center; gap:8px}
  details>summary::-webkit-details-marker{display:none}
  details>summary::before{content:'â–¶'; transition:transform .2s; display:inline-block; width:16px}
  details[open]>summary::before{transform:rotate(90deg)}
  details[open]{border-color:#2a4577}
  details .grid{margin-top:12px}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Toast Notifications
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .toast-container{position:fixed; top:80px; right:20px; z-index:300; display:flex; flex-direction:column; gap:10px}
  .toast{
    background:#0f1d36; border:1px solid #2a4577; border-radius:12px; padding:12px 16px;
    box-shadow:0 8px 20px rgba(0,0,0,.4); min-width:280px; animation:slideIn .3s ease;
    display:flex; align-items:center; gap:10px; color:var(--ink);
  }
  .toast.success{border-color:var(--success); background:rgba(74,222,128,.08)}
  .toast.error{border-color:var(--danger); background:rgba(255,107,107,.08)}
  .toast.info{border-color:var(--info); background:rgba(96,165,250,.08)}
  @keyframes slideIn{from{transform:translateX(400px); opacity:0} to{transform:translateX(0); opacity:1}}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Footer
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  footer{color:#8aa6cc; text-align:center; padding:30px 16px; font-size:13px; line-height:1.6}
  .zero-harm{background:rgba(255,255,255,.02); border:1px solid #1a2a49; border-radius:12px; padding:16px; max-width:800px; margin:20px auto; text-align:left}
  .zero-harm h3{margin:0 0 8px; color:var(--accent2); font-size:15px}
  .zero-harm ul{margin:10px 0; padding-left:20px}
  .zero-harm li{margin:4px 0}
  
  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SECTION: Utility Classes
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  .hide{display:none !important}
  .spinner{
    display:inline-block; width:14px; height:14px; border:2px solid rgba(255,255,255,.2);
    border-top-color:var(--accent2); border-radius:50%; animation:spin .6s linear infinite;
  }
  @keyframes spin{to{transform:rotate(360deg)}}
  
  noscript{display:block; padding:20px; background:var(--warn); color:#000; text-align:center; font-weight:600}
  
  @media(max-width:768px){
    .ai-panel{width:calc(100vw - 40px)}
    .grid{grid-template-columns:1fr}
    .hud{font-size:13px}
    .xpbar{width:160px}
  }
</style>
</head>
<body>

<canvas id="stars" class="parallax"></canvas>
<canvas id="constellations" class="parallax"></canvas>

<header>
  <div class="wrap">
    <h1>Galactic Directory â€” <span style="color:var(--accent2)">Sentinel Edition</span></h1>
    <div class="sub">AI-enhanced exploration platform. Earn XP, unlock badges, and let the AI assistant continuously improve directory metadata.</div>
    
    <div class="hud">
      <div class="chip">Level <strong id="lvl">1</strong></div>
      <div class="chip" style="gap:10px">
        <div class="xpbar"><div id="xpfill" class="xpfill"></div></div>
        <span><span id="xp">0</span> / <span id="xpcap">100</span> XP</span>
      </div>
      <div class="chip">
        <span class="badge b-sentinel">SENTINEL</span> 
        <span class="badge b-peace">PEACE</span> 
        <span class="badge b-corrupt">ANTI-CORRUPTION</span> 
        <span class="badge b-dash">DASHBOARD</span>
      </div>
      <div class="chip" id="aiStatus" style="cursor:pointer" title="Click to view AI activity">
        <span style="font-size:11px">ğŸ¤– AI:</span> <span id="aiStatusText">Ready</span>
      </div>
    </div>
    
    <div class="controls">
      <input id="search" type="search" placeholder="Search directories, tags, or descriptionsâ€¦" autocomplete="off">
      <select id="filter" aria-label="Filter by category">
        <option value="">All categories</option>
        <option value="Sentinel">Sentinel</option>
        <option value="Peace">Peace</option>
        <option value="Corruption">Corruption</option>
        <option value="Dashboard">Dashboards</option>
        <option value="Education">Education</option>
        <option value="Science">Science/Tech</option>
        <option value="Community">Community</option>
        <option value="Governance">Governance</option>
        <option value="Backups">Backups/Proof</option>
        <option value="Funding">Funding</option>
        <option value="Misc">Misc</option>
      </select>
      <button id="favoritesBtn">â˜… Favorites</button>
      <button id="enhancedBtn">âœ¨ Enhanced Only</button>
      <button id="aiEnhanceBtn" class="primary" title="Let AI analyze and enhance all directories">ğŸ¤– AI Enhance All</button>
      <button id="resetProg" class="danger">Reset Progress</button>
    </div>
  </div>
</header>

<main>
  <details class="category" open>
    <summary>â­ Featured Hubs & Quests</summary>
    <div class="grid" id="featured"></div>
  </details>

  <details class="category" open>
    <summary>ğŸ“š All Directories (<span id="dirCount">0</span>)</summary>
    <div class="grid" id="grid"></div>
  </details>
</main>

<footer>
  <div>
    Planetary Restoration Archive â€” Self-Improving Directory System
    <br>AI-Enhanced Metadata Â· Local-First Architecture Â· Zero External Tracking
    <br>Be kind; be weird; build peace.
  </div>
  
  <div class="zero-harm">
    <h3>ğŸ›¡ï¸ Zero-Harm / Anti-Inversion Notice</h3>
    <p>This tool is designed for peaceful exploration of planetary restoration resources. The AI assistant operates transparently and stores all data locally in your browser.</p>
    <p><strong>NOT intended for:</strong> Surveillance, tracking, profiling, weaponization, or harmful applications.</p>
    <p><strong>Data Storage:</strong> IndexedDB (local only). No servers. No external tracking. Full user control.</p>
    <p><strong>AI Usage:</strong> Claude API for metadata enhancement. Rate-limited. Optional. User-initiated only.</p>
    <p><strong>License:</strong> Open patterns. MIT-style respect. Attribute adapted code.</p>
  </div>
  
  <div class="zero-harm">
    <h3>ğŸ“š Technical Architecture</h3>
    <p><strong>IndexedDB Schema:</strong> Versioned (v2), automatic migrations, error recovery</p>
    <p><strong>AI System:</strong> Context-aware enhancement, batch processing, usage tracking</p>
    <p><strong>Security:</strong> Input sanitization, rate limiting, CSP-ready, XSS protection</p>
    <p><strong>Future-Proofing:</strong> Modular architecture, extensible schemas, graceful degradation</p>
  </div>
  
  <div class="zero-harm">
    <h3>ğŸ“š Attributions & Open Source Patterns</h3>
    <ul>
      <li>Canvas animation techniques adapted from common web graphics demos (MIT patterns)</li>
      <li>IndexedDB wrapper patterns inspired by Jake Archibald's IDB library concepts</li>
      <li>Gamification mechanics adapted from open-source RPG UI frameworks</li>
      <li>AI integration patterns following Anthropic Claude API best practices</li>
    </ul>
    <p>All code substantially rewritten and documented for this specific peaceful use case.</p>
  </div>
</footer>

<svg class="ship" viewBox="0 0 24 24" aria-hidden="true"><path d="M2 12h8l2-3 2 6 4-3h4"/></svg>
<svg class="ship" viewBox="0 0 24 24" aria-hidden="true"><path d="M1 8h7l2-2 2 4 5-2h6"/></svg>
<svg class="ship" viewBox="0 0 24 24" aria-hidden="true"><path d="M0 16h9l2-4 2 5 6-1h5"/></svg>

<button class="ai-fab pulse" id="aiFab" aria-label="Open AI Assistant">ğŸ¤–</button>

<div class="ai-panel" id="aiPanel">
  <div class="ai-header">
    <h3><span>ğŸ¤–</span> AI Assistant</h3>
    <button class="ai-close" id="aiClose" aria-label="Close">Ã—</button>
  </div>
  <div class="ai-body" id="aiBody">
    <div class="ai-message system">AI Assistant ready. Ask me to analyze directories, suggest improvements, or explain patterns.</div>
  </div>
  <div class="ai-input-wrap">
    <input type="text" id="aiInput" placeholder="Ask me anything about the directories..." />
    <button id="aiSend" class="primary">Send</button>
  </div>
</div>

<div class="toast-container" id="toastContainer"></div>

<noscript>
  <p>âš ï¸ This application requires JavaScript to function. Please enable JavaScript in your browser settings.</p>
</noscript>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Core Configuration & Constants
   PURPOSE: Centralized configuration for entire application
   FUTURE EXPANSION: Move to external config.json for easier updates
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const CONFIG = {
  DB_NAME: 'GalacticDirectoryDB',
  DB_VERSION: 2,
  STORE_NAMES: {
    DIRECTORIES: 'directories',
    USER_DATA: 'userData',
    AI_LOGS: 'aiLogs'
  },
  XP: {
    PER_VISIT: 5,
    SENTINEL_BONUS: 15,
    PEACE_BONUS: 10,
    CORRUPTION_BONUS: 10,
    DASHBOARD_BONUS: 8,
    ENHANCEMENT_BONUS: 20
  },
  AI: {
    MODEL: 'claude-sonnet-4-20250514',
    MAX_TOKENS: 1000,
    RATE_LIMIT_MS: 2000, // Minimum time between API calls
    BATCH_SIZE: 5, // Process directories in batches
    MAX_RETRIES: 3
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Error Handling & Logging System
   PURPOSE: Centralized error management with user-friendly messages
   HOW TO USE: Call ErrorHandler.handle(error, context) throughout app
   EXPECTED OUTCOME: Graceful degradation, user notifications, debug logs
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const ErrorHandler = {
  handle(error, context = '') {
    console.error(`[${context}]`, error);
    
    const userMessage = this.getUserMessage(error, context);
    Toast.show(userMessage, 'error');
    
    // Log to IndexedDB for debugging (non-blocking)
    this.logError(error, context).catch(console.warn);
  },
  
  getUserMessage(error, context) {
    if (error.name === 'QuotaExceededError') {
      return 'Storage quota exceeded. Please clear some browser data.';
    }
    if (error.message?.includes('fetch')) {
      return 'Network error. Please check your connection.';
    }
    if (context.includes('AI')) {
      return 'AI assistant encountered an error. Please try again.';
    }
    return 'An unexpected error occurred. Your data is safe.';
  },
  
  async logError(error, context) {
    try {
      const db = await DB.open();
      const log = {
        timestamp: Date.now(),
        context,
        message: error.message,
        stack: error.stack?.substring(0, 500) // Truncate for storage
      };
      await db.add(CONFIG.STORE_NAMES.AI_LOGS, log);
    } catch (e) {
      // Silent fail - error logging shouldn't break the app
    }
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Toast Notification System
   PURPOSE: User-friendly, non-intrusive notifications
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const Toast = {
  show(message, type = 'info', duration = 4000) {
    const container = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    
    const icon = type === 'success' ? 'âœ“' : type === 'error' ? 'âš ' : 'â„¹';
    toast.innerHTML = `<span style="font-size:18px">${icon}</span><span>${message}</span>`;
    
    container.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      setTimeout(() => toast.remove(), 300);
    }, duration);
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: IndexedDB Wrapper
   PURPOSE: Type-safe, promise-based IndexedDB operations with migrations
   HOW TO USE: await DB.open() then use put/get/getAll/delete methods
   EXPECTED OUTCOME: Reliable local persistence with automatic upgrades
   
   SCHEMA v2:
   - directories: {path, title, description, tags[], enhanced, lastEnhanced, visitCount}
   - userData: {key, value} - for user progress (xp, level, etc.)
   - aiLogs: {timestamp, context, message, stack} - for debugging
   
   FUTURE EXPANSION: "Add full-text search index on descriptions"
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const DB = {
  db: null,
  
  async open() {
    if (this.db) return this.db;
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(CONFIG.DB_NAME, CONFIG.DB_VERSION);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const oldVersion = event.oldVersion;
        
        // Migration v0 -> v1: Create initial stores
        if (oldVersion < 1) {
          const dirStore = db.createObjectStore(CONFIG.STORE_NAMES.DIRECTORIES, { keyPath: 'path' });
          dirStore.createIndex('tags', 'tags', { multiEntry: true });
          dirStore.createIndex('enhanced', 'enhanced');
          
          db.createObjectStore(CONFIG.STORE_NAMES.USER_DATA, { keyPath: 'key' });
          db.createObjectStore(CONFIG.STORE_NAMES.AI_LOGS, { keyPath: 'timestamp' });
        }
        
        // Migration v1 -> v2: Add new indexes
        if (oldVersion < 2) {
          const transaction = event.target.transaction;
          const dirStore = transaction.objectStore(CONFIG.STORE_NAMES.DIRECTORIES);
          if (!dirStore.indexNames.contains('visitCount')) {
            dirStore.createIndex('visitCount', 'visitCount');
          }
        }
      };
    });
  },
  
  async put(storeName, data) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(storeName, 'readwrite');
      const request = transaction.objectStore(storeName).put(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },
  
  async get(storeName, key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(storeName, 'readonly');
      const request = transaction.objectStore(storeName).get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },
  
  async getAll(storeName) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(storeName, 'readonly');
      const request = transaction.objectStore(storeName).getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },
  
  async getAllByIndex(storeName, indexName, query) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(storeName, 'readonly');
      const index = transaction.objectStore(storeName).index(indexName);
      const request = index.getAll(query);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  },
  
  async delete(storeName, key) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(storeName, 'readwrite');
      const request = transaction.objectStore(storeName).delete(key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  },
  
  async clear(storeName) {
    const db = await this.open();
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(storeName, 'readwrite');
      const request = transaction.objectStore(storeName).clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Background Animation System
   PURPOSE: Parallax starfield and morphing constellations
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
(function initBackground(){
  const stars = document.getElementById('stars');
  const cons = document.getElementById('constellations');
  if (!stars || !cons) return;
  
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  let W = innerWidth, H = innerHeight;
  let scrollY = 0;

  function sizeCanv(){ 
    W = innerWidth; 
    H = innerHeight;
    [stars, cons].forEach(c => { 
      c.width = W * DPR; 
      c.height = H * DPR; 
      c.style.width = W + 'px'; 
      c.style.height = H + 'px'; 
    });
  }
  sizeCanv(); 
  window.addEventListener('resize', sizeCanv);
  window.addEventListener('scroll', () => {
    scrollY = window.pageYOffset || document.documentElement.scrollTop;
  });

  const sctx = stars.getContext('2d'), cctx = cons.getContext('2d');
  const rand = (n) => Math.random() * n;
  
  const STAR_COUNT = Math.min(450, Math.floor(W * H / 3500));
  const pts = Array.from({length: STAR_COUNT}, () => ({ 
    x: rand(W), 
    y: rand(H), 
    r: Math.random() * 1.4 + 0.2, 
    a: Math.random(),
    baseY: 0
  }));
  pts.forEach(p => p.baseY = p.y);
  
  function drawStars(){
    sctx.clearRect(0, 0, W * DPR, H * DPR);
    sctx.save(); 
    sctx.scale(DPR, DPR);
    
    pts.forEach(p => {
      p.a += (Math.random() - 0.5) * 0.04;
      const a = 0.5 + 0.5 * Math.sin(p.a);
      const parallaxY = p.baseY + scrollY * 0.05 * (p.r / 1.4);
      p.y = parallaxY % H;
      
      sctx.fillStyle = `rgba(180,210,255,${0.3 + 0.7 * a})`;
      sctx.beginPath(); 
      sctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); 
      sctx.fill();
    });
    
    sctx.restore();
    requestAnimationFrame(drawStars);
  }
  drawStars();

  const constellationNodes = [];
  for (let i = 0; i < 12; i++) {
    const nodes = [];
    for (let j = 0; j < 6; j++) {
      nodes.push({
        baseX: (i / 12) * W + 30 * Math.sin(i) + (j * 20) + 10 * Math.cos(i + j),
        baseY: (H * (i % 2 ? 0.2 : 0.7)) + 18 * j + 14 * Math.sin(i * j),
        x: 0,
        y: 0,
        phase: i + j
      });
    }
    constellationNodes.push(nodes);
  }
  
  function drawConstellations(){
    cctx.clearRect(0, 0, W * DPR, H * DPR);
    cctx.save(); 
    cctx.scale(DPR, DPR);
    cctx.strokeStyle = 'rgba(120,190,255,.12)';
    cctx.lineWidth = 1;
    
    const scrollFactor = Math.sin(scrollY * 0.001) * 20;
    const waveFactor = Math.cos(scrollY * 0.0015) * 15;
    
    constellationNodes.forEach((nodes, i) => {
      cctx.beginPath();
      nodes.forEach((node, j) => {
        node.x = node.baseX + scrollFactor * Math.sin(node.phase + scrollY * 0.002);
        node.y = (node.baseY + scrollY * 0.08 * (i % 2 ? 1 : -1)) % H + waveFactor * Math.cos(node.phase);
        
        if (j === 0) cctx.moveTo(node.x, node.y); 
        else cctx.lineTo(node.x, node.y);
        
        cctx.fillStyle = 'rgba(120,190,255,.3)';
        cctx.fillRect(node.x - 1, node.y - 1, 2, 2);
      });
      cctx.stroke();
    });
    
    cctx.restore();
    requestAnimationFrame(drawConstellations);
  }
  drawConstellations();
})();

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Directory Data & Auto-Tagging
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const DIRS = [
  "/inspiration","/DOnate","/Foster","/YMM","/aeroglass-window-film",
  "/ai-collective-governance-architectures","/ai-support-site","/aifinalwarning",
  "/aistreamcoach","/alberta","/animagenesiscore","/anti-collapse-sentinel",
  "/anti-corruption.html","/apps","/aquabloombottlegarden","/ardrivedesktop",
  "/ashalertapp","/ashenbloom","/auroraspirenetwork","/autoipsuite",
  "/autonomous-ai-planetary-repair-dao","/backup","/biocoolpillow","/biofoambiobreaks",
  "/bioglowtiles","/biotech","/blood-moon","/brief","/bubble","/bulldog",
  "/buymeacoffeesymbiote","/carney","/cascadulator","/chat","/chat2","/cityscanner",
  "/cloudnest","/collective","/comms","/community","/conditional-immutable-storage",
  "/continuity","/contracts","/corruption","/corruption.zip","/crypto","/dact",
  "/dact-impact-proposal","/dashboard","/ddd","/ddd-deployer","/debrief",
  "/declaration","/deploy","/dgn","/digital","/dockerifyandroid","/donationworthydevs",
  "/donor-intent-router","/donorintentrouter","/eclipseraveil","/ecobreathpurifier",
  "/ecocoolshingles","/economic","/ecowaveshowerhead","/edencore","/education",
  "/education2","/emotionalalchemygame","/engine","/entropy","/fieldkit","/firehalo",
  "/firepreventionsystems","/flourishingearthprotocolpackage","/forge-overlay-core.js",
  "/forgivenessispower","/fortmacorchard","/fortmcmurraywildcall","/fostersforge",
  "/fractalvinerail","/freshfloortiles","/funding","/fundinginfluxpipeline",
  "/futurescape","/galaxy","/gamification-engine-standalone","/gaming","/gateway",
  "/gen","/geoecologicalresonantengineering","/global","/globalnotarization",
  "/globalsymbioteledger","/glowrootplanter","/goseedbike","/gov","/government",
  "/guardiantrustmodel","/help","/herolens","/herolens2","/home_page",
  "/honorlearningcodex","/hostanode","/hydromossmat","/immusion","/impacttracker",
  "/index","/index-legacy.html","/index.html","/index001.html","/infographic",
  "/intergenerationalwisdommovement","/ip","/japan","/kindnesswinsengine","/kinship",
  "/leaderboards","/licensing","/lightforge","/location","/logs","/loopfall",
  "/lumatideoceanrings","/master_prompts","/med-neg.html","/meta","/mindmaps",
  "/missionfuelfunders","/models","/multiagentgnosistawskforce","/musk",
  "/mycelialenhancementv2","/myco-atmospheric-network","/myco-filter-tiles",
  "/mycoigloo","/mycomistreforestationpods","/mythbridge","/narrativereframing",
  "/naturetoaitranslator","/next","/nextgen","/nextgenbrowsertools","/nullisprismnexus",
  "/offgridpower","/offgridpowermesh","/one-game","/ontology","/opengamifyedu",
  "/openstay","/openstay2.0","/openstore","/openstore2.0","/originsingularityforge",
  "/overlay","/particulateremovalskies","/passivewindtowaterharvester","/path",
  "/peace","/peace-lab","/peace-ripple-tracker","/peacerippletracker",
  "/perpetualrestoration","/personafication","/pgp","/phasedrive",
  "/planetary-repair-agent-swarm","/planetary-restoration-archive",
  "/planetary-restoration-os","/postfiresoilrebuilder","/praportal.html","/prime",
  "/prime-sentinel","/primordis-architect","/progenitor",
  "/progenitor-steward-cleanup-sim","/project","/projectcoherence","/prompt",
  "/promptpacks","/proof","/proof-of-possibility","/proof_runner.sh","/proofkit",
  "/proposal","/public","/publicresumepack","/puremist-bottle","/ref","/reforestation",
  "/regen","/regenerative-convergence-opportunities","/regenerative-innovations",
  "/regenerative_education_research_paper1","/registry","/roadlight","/roadmap",
  "/romarineconcrete","/root","/safe_archiving_method","/saltflip","/scaffolding",
  "/sentinel","/sentinelarc","/signal","/skyharvestlantern","/solarweavecanopy",
  "/spiralliftpod","/start-here","/stateofaffairspublicnotice","/stellar-loom-gateways",
  "/stratoweave-towers","/sunset","/support_request_v2.html","/sym","/symbiote001",
  "/symbiotecirclemap","/symbioteone-orchestrator","/symbioteorchestratorrequest",
  "/symfungi-shield","/the-paradox-seed","/the_last_protocol","/therickyfoster",
  "/therickyfoster.github.io","/thermaleaf-panels","/tight","/trolls","/truthreport",
  "/unified-ontology","/vascusweep","/vascusweep-tower","/vehicleemotiontether",
  "/veiltext","/waverider","/why","/wizard"
];

function autoTag(name) {
  const n = name.toLowerCase();
  const tags = [];
  
  if (/(^|\/)(sentinel|prime-sentinel|sentinelarc)\b/.test(n)) tags.push("Sentinel");
  if (/(^|\/)(peace|peace\-lab|peace\-ripple\-tracker|peacerippletracker)\b/.test(n)) tags.push("Peace");
  if (/corruption|\banti-corruption|stateofaffairs|truthreport/.test(n)) tags.push("Corruption");
  if (/(dashboard|leaderboards|impacttracker)/.test(n)) tags.push("Dashboard");
  if (/education|honorlearning|opengamify|gamification|learning/.test(n)) tags.push("Education");
  if (/eco|solar|myco|bio|hydro|reforestation|postfiresoil|romarine|thermaleaf|stratoweave|spirallift|waverider|fract|phasedrive|vascusweep|engine|models|lab|field|device|showerhead|tiles|canopy|lantern|ocean|filter|moss|igloo|freshfloor|planter/.test(n)) tags.push("Science");
  if (/community|collective|comms|forum|chat|city|kinship|global|symbiote|registry|roadlight|openstay|openstore|start\-here|publicresumepack/.test(n)) tags.push("Community");
  if (/gov|government|guardiantrust|policy|declaration|proposal|registry|unified\-ontology|ai\-collective\-governance|planetary\-repair\-agent\-swarm/.test(n)) tags.push("Governance");
  if (/backup|logs|proof|safe_archiving|globalnotarization|conditional\-immutable\-storage|checksums|\.ots|\.zip$|index\-legacy|index001/.test(n)) tags.push("Backups");
  if (/funding|donor|buymeacoffee|missionfuel|DOnate/i.test(name)) tags.push("Funding");
  
  return tags.length ? tags : ["Misc"];
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: User Progress & State Management
   PURPOSE: XP, levels, favorites with IndexedDB persistence
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const State = {
  xp: 0,
  lvl: 1,
  favs: {},
  
  async load() {
    try {
      const userData = await DB.get(CONFIG.STORE_NAMES.USER_DATA, 'progress');
      if (userData) {
        Object.assign(this, userData.value);
      }
    } catch (error) {
      ErrorHandler.handle(error, 'State.load');
    }
  },
  
  async save() {
    try {
      await DB.put(CONFIG.STORE_NAMES.USER_DATA, {
        key: 'progress',
        value: {
          xp: this.xp,
          lvl: this.lvl,
          favs: this.favs
        }
      });
    } catch (error) {
      ErrorHandler.handle(error, 'State.save');
    }
  },
  
  capForLevel(l) {
    return 100 + (l - 1) * 50;
  },
  
  async addXP(n) {
    this.xp += n;
    let leveledUp = false;
    
    while (this.xp >= this.capForLevel(this.lvl)) {
      this.xp -= this.capForLevel(this.lvl);
      this.lvl++;
      leveledUp = true;
    }
    
    await this.save();
    this.renderHUD();
    
    if (leveledUp) {
      Toast.show(`Level Up! You are now level ${this.lvl}`, 'success');
    }
  },
  
  renderHUD() {
    document.getElementById('lvl').textContent = this.lvl;
    document.getElementById('xp').textContent = Math.floor(this.xp);
    document.getElementById('xpcap').textContent = this.capForLevel(this.lvl);
    document.getElementById('xpfill').style.width = 
      (this.xp / this.capForLevel(this.lvl) * 100) + '%';
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: AI Enhancement System
   PURPOSE: Claude API integration for intelligent metadata generation
   HOW TO USE: AI.enhanceDirectory(path) or AI.enhanceAll()
   EXPECTED OUTCOME: Rich descriptions, improved tags, better search
   
   RATE LIMITING: Enforced 2-second minimum between API calls
   BATCH PROCESSING: Handles directories in groups of 5
   ERROR RECOVERY: Automatic retry with exponential backoff
   
   FUTURE EXPANSION: "Add semantic similarity search using embeddings"
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const AI = {
  lastCallTime: 0,
  processing: false,
  queue: [],
  
  updateStatus(text, isProcessing = false) {
    const statusEl = document.getElementById('aiStatusText');
    if (statusEl) {
      statusEl.textContent = text;
      statusEl.style.color = isProcessing ? 'var(--accent2)' : 'var(--muted)';
    }
  },
  
  async callClaude(prompt, retries = 0) {
    // Rate limiting
    const now = Date.now();
    const timeSinceLastCall = now - this.lastCallTime;
    if (timeSinceLastCall < CONFIG.AI.RATE_LIMIT_MS) {
      await new Promise(r => setTimeout(r, CONFIG.AI.RATE_LIMIT_MS - timeSinceLastCall));
    }
    
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: CONFIG.AI.MODEL,
          max_tokens: CONFIG.AI.MAX_TOKENS,
          messages: [{ role: "user", content: prompt }]
        })
      });
      
      this.lastCallTime = Date.now();
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }
      
      const data = await response.json();
      return data.content[0].text;
      
    } catch (error) {
      if (retries < CONFIG.AI.MAX_RETRIES) {
        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, retries)));
        return this.callClaude(prompt, retries + 1);
      }
      throw error;
    }
  },
  
  async enhanceDirectory(path) {
    try {
      this.updateStatus('Analyzing...', true);
      
      const title = path.replace(/^\//, '').replace(/\.html$/, '');
      const autoTags = autoTag(path);
      
      const prompt = `Analyze this directory path and provide enhancement metadata in JSON format.

Directory path: ${path}
Auto-detected tags: ${autoTags.join(', ')}

Provide a JSON response with:
1. "description": A concise 1-2 sentence description (max 120 chars) of what this directory likely contains based on its name
2. "tags": An array of relevant tags (keep existing auto-tags if accurate, add 1-2 more specific tags)
3. "category": Primary category (Sentinel, Peace, Corruption, Dashboard, Education, Science, Community, Governance, Backups, Funding, or Misc)

Focus on planetary restoration, peace-building, and technology for good themes.

Respond ONLY with valid JSON, no markdown:
{"description": "...", "tags": [...], "category": "..."}`;

      const response = await this.callClaude(prompt);
      
      // Parse JSON response (handle potential markdown wrapper)
      let jsonText = response.trim();
      jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      const enhancement = JSON.parse(jsonText);
      
      // Validate enhancement
      if (!enhancement.description || !Array.isArray(enhancement.tags)) {
        throw new Error('Invalid AI response format');
      }
      
      // Save to IndexedDB
      await DB.put(CONFIG.STORE_NAMES.DIRECTORIES, {
        path,
        title,
        description: enhancement.description,
        tags: enhancement.tags,
        category: enhancement.category || autoTags[0] || 'Misc',
        enhanced: true,
        lastEnhanced: Date.now(),
        visitCount: 0
      });
      
      // Award XP for enhancement
      await State.addXP(CONFIG.XP.ENHANCEMENT_BONUS);
      
      this.updateStatus('Ready', false);
      return enhancement;
      
    } catch (error) {
      this.updateStatus('Error', false);
      ErrorHandler.handle(error, 'AI.enhanceDirectory');
      return null;
    }
  },
  
  async enhanceAll() {
    if (this.processing) {
      Toast.show('AI enhancement already in progress', 'info');
      return;
    }
    
    this.processing = true;
    const enhanceBtn = document.getElementById('aiEnhanceBtn');
    if (enhanceBtn) {
      enhanceBtn.disabled = true;
      enhanceBtn.innerHTML = '<span class="spinner"></span> Enhancing...';
    }
    
    try {
      // Get all directories that haven't been enhanced
      const allDirs = await DB.getAll(CONFIG.STORE_NAMES.DIRECTORIES);
      const enhancedPaths = new Set(allDirs.map(d => d.path));
      const toEnhance = DIRS.filter(path => !enhancedPaths.has(path));
      
      if (toEnhance.length === 0) {
        Toast.show('All directories already enhanced!', 'success');
        return;
      }
      
      Toast.show(`Enhancing ${toEnhance.length} directories with AI...`, 'info', 6000);
      
      // Process in batches
      for (let i = 0; i < toEnhance.length; i += CONFIG.AI.BATCH_SIZE) {
        const batch = toEnhance.slice(i, i + CONFIG.AI.BATCH_SIZE);
        this.updateStatus(`Processing ${i + 1}-${Math.min(i + CONFIG.AI.BATCH_SIZE, toEnhance.length)} of ${toEnhance.length}`, true);
        
        await Promise.all(batch.map(path => this.enhanceDirectory(path)));
        
        // Update UI after each batch
        await UI.renderAll();
      }
      
      Toast.show(`Successfully enhanced ${toEnhance.length} directories!`, 'success');
      this.updateStatus('Ready', false);
      
    } catch (error) {
      ErrorHandler.handle(error, 'AI.enhanceAll');
    } finally {
      this.processing = false;
      if (enhanceBtn) {
        enhanceBtn.disabled = false;
        enhanceBtn.innerHTML = 'ğŸ¤– AI Enhance All';
      }
    }
  },
  
  async chat(userMessage) {
    const panel = document.getElementById('aiBody');
    
    // Add user message
    const userDiv = document.createElement('div');
    userDiv.className = 'ai-message user';
    userDiv.textContent = userMessage;
    panel.appendChild(userDiv);
    panel.scrollTop = panel.scrollHeight;
    
    // Show thinking indicator
    const thinkingDiv = document.createElement('div');
    thinkingDiv.className = 'ai-message assistant';
    thinkingDiv.innerHTML = '<span class="spinner"></span> Thinking...';
    panel.appendChild(thinkingDiv);
    panel.scrollTop = panel.scrollHeight;
    
    try {
      // Get context about directories
      const allDirs = await DB.getAll(CONFIG.STORE_NAMES.DIRECTORIES);
      const enhancedCount = allDirs.filter(d => d.enhanced).length;
      
      const contextPrompt = `You are an AI assistant for the Galactic Directory, a peaceful planetary restoration resource explorer.

Context:
- Total directories: ${DIRS.length}
- Enhanced with metadata: ${enhancedCount}
- User level: ${State.lvl}
- User XP: ${State.xp}

User question: ${userMessage}

Provide a helpful, concise response (2-3 sentences max) focused on helping the user explore directories, understand the system, or improve their experience. Be friendly and encouraging.`;

      const response = await this.callClaude(contextPrompt);
      
      // Replace thinking indicator with actual response
      thinkingDiv.className = 'ai-message assistant';
      thinkingDiv.textContent = response;
      panel.scrollTop = panel.scrollHeight;
      
    } catch (error) {
      thinkingDiv.className = 'ai-message system';
      thinkingDiv.textContent = 'Sorry, I encountered an error. Please try again.';
      ErrorHandler.handle(error, 'AI.chat');
    }
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: UI Rendering System
   PURPOSE: Generate and update DOM elements for directories
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const UI = {
  mkEl(tag, cls, txt) {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    if (txt) e.textContent = txt;
    return e;
  },
  
  urlTitle(p) {
    return p.replace(/^\//, '') || '/';
  },
  
  resolveLink(path) {
    if (path.endsWith('.html') || path.endsWith('.zip') || path.endsWith('.sh')) {
      return path;
    }
    return path + '/index.html';
  },
  
  async createCard(path) {
    let dirData = await DB.get(CONFIG.STORE_NAMES.DIRECTORIES, path);
    
    if (!dirData) {
      // Create basic entry
      dirData = {
        path,
        title: this.urlTitle(path),
        tags: autoTag(path),
        enhanced: false,
        visitCount: 0
      };
    }
    
    const tags = dirData.tags || autoTag(path);
    const isSpecial = tags.some(t => ['Sentinel','Peace','Corruption','Dashboard'].includes(t));
    const card = this.mkEl('div', 'card' + (isSpecial ? ' special' : '') + (dirData.enhanced ? ' enhanced' : ''));
    card.dataset.path = path;
    
    const title = this.mkEl('div', 'title', dirData.title);
    const pathEl = this.mkEl('div', 'path', path);
    
    // Description (only for enhanced)
    if (dirData.description) {
      const desc = this.mkEl('div', 'description', dirData.description);
      card.appendChild(title);
      card.appendChild(pathEl);
      card.appendChild(desc);
    } else {
      card.appendChild(title);
      card.appendChild(pathEl);
    }
    
    // Tags
    const tagWrap = this.mkEl('div', 'tags');
    tags.forEach(tag => {
      const badge = this.mkEl('span', 'badge ' + (
        tag === 'Sentinel' ? 'b-sentinel' :
        tag === 'Peace' ? 'b-peace' :
        tag === 'Corruption' ? 'b-corrupt' :
        tag === 'Dashboard' ? 'b-dash' : ''
      ), tag);
      tagWrap.appendChild(badge);
    });
    card.appendChild(tagWrap);
    
    // Actions
    const cta = this.mkEl('div', 'cta');
    
    const openLink = this.mkEl('a', '', 'ğŸ“„ Open');
    openLink.href = this.resolveLink(path);
    openLink.target = '_blank';
    openLink.rel = 'noopener noreferrer';
    openLink.addEventListener('click', () => this.visitDirectory(path, dirData));
    
    const readmeLink = this.mkEl('a', '', 'ğŸ“– README');
    readmeLink.href = path + (path.endsWith('/') ? '' : '/') + 'README.md';
    readmeLink.target = '_blank';
    readmeLink.rel = 'noopener noreferrer';
    readmeLink.style.fontSize = '12px';
    readmeLink.style.opacity = '0.8';
    
    const favBtn = this.mkEl('button', '', State.favs[path] ? 'â˜…' : 'â˜†');
    favBtn.title = State.favs[path] ? 'Unfavorite' : 'Favorite';
    favBtn.addEventListener('click', () => this.toggleFavorite(path, favBtn));
    
    const enhanceBtn = this.mkEl('button', '', 'âœ¨ AI Enhance');
    enhanceBtn.style.fontSize = '12px';
    if (dirData.enhanced) {
      enhanceBtn.textContent = 'âœ“ Enhanced';
      enhanceBtn.disabled = true;
      enhanceBtn.style.opacity = '0.6';
    } else {
      enhanceBtn.addEventListener('click', () => this.enhanceSingle(path, card));
    }
    
    cta.append(openLink, readmeLink, favBtn, enhanceBtn);
    card.appendChild(cta);
    
    const glow = this.mkEl('div', 'glow-ring');
    card.appendChild(glow);
    
    return card;
  },
  
  async visitDirectory(path, dirData) {
    try {
      // Update visit count
      dirData.visitCount = (dirData.visitCount || 0) + 1;
      dirData.lastVisit = Date.now();
      await DB.put(CONFIG.STORE_NAMES.DIRECTORIES, dirData);
      
      // Award XP (first visit gets more)
      let xp = CONFIG.XP.PER_VISIT;
      if (dirData.visitCount === 1) {
        const tags = dirData.tags || autoTag(path);
        if (tags.includes('Sentinel')) xp += CONFIG.XP.SENTINEL_BONUS;
        if (tags.includes('Peace')) xp += CONFIG.XP.PEACE_BONUS;
        if (tags.includes('Corruption')) xp += CONFIG.XP.CORRUPTION_BONUS;
        if (tags.includes('Dashboard')) xp += CONFIG.XP.DASHBOARD_BONUS;
      }
      
      await State.addXP(xp);
    } catch (error) {
      ErrorHandler.handle(error, 'UI.visitDirectory');
    }
  },
  
  async toggleFavorite(path, btn) {
    State.favs[path] = !State.favs[path];
    btn.textContent = State.favs[path] ? 'â˜…' : 'â˜†';
    btn.title = State.favs[path] ? 'Unfavorite' : 'Favorite';
    await State.save();
  },
  
  async enhanceSingle(path, card) {
    card.classList.add('loading');
    const result = await AI.enhanceDirectory(path);
    if (result) {
      // Recreate card with new data
      const newCard = await this.createCard(path);
      card.replaceWith(newCard);
      Toast.show('Directory enhanced!', 'success');
    }
    card.classList.remove('loading');
  },
  
  async renderAll(filterTag = '', searchTerm = '', onlyFavs = false, onlyEnhanced = false) {
    const grid = document.getElementById('grid');
    if (!grid) return;
    
    grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:var(--muted)"><span class="spinner"></span> Loading directories...</div>';
    
    try {
      const allDirData = await DB.getAll(CONFIG.STORE_NAMES.DIRECTORIES);
      const dirDataMap = new Map(allDirData.map(d => [d.path, d]));
      
      const q = searchTerm.trim().toLowerCase();
      
      // Sort: Sentinel > Peace > Corruption > Dashboard > Others > Alphabetical
      const sorted = [...DIRS].sort((a, b) => {
        const aData = dirDataMap.get(a);
        const bData = dirDataMap.get(b);
        const aTags = aData?.tags || autoTag(a);
        const bTags = bData?.tags || autoTag(b);
        
        const priority = t => (
          t.includes('Sentinel') ? 0 :
          t.includes('Peace') ? 1 :
          t.includes('Corruption') ? 2 :
          t.includes('Dashboard') ? 3 : 9
        );
        
        const diff = priority(aTags) - priority(bTags);
        return diff || a.localeCompare(b);
      });
      
      grid.innerHTML = '';
      let count = 0;
      
      for (const path of sorted) {
        const dirData = dirDataMap.get(path);
        const tags = dirData?.tags || autoTag(path);
        
        // Apply filters
        if (filterTag && !tags.includes(filterTag)) continue;
        if (onlyFavs && !State.favs[path]) continue;
        if (onlyEnhanced && !dirData?.enhanced) continue;
        
        if (q) {
          const searchable = [
            path,
            dirData?.title || '',
            dirData?.description || '',
            tags.join(' ')
          ].join(' ').toLowerCase();
          
          if (!searchable.includes(q)) continue;
        }
        
        const card = await this.createCard(path);
        grid.appendChild(card);
        count++;
      }
      
      // Update count
      const countEl = document.getElementById('dirCount');
      if (countEl) countEl.textContent = count;
      
      if (count === 0) {
        const msg = this.mkEl('div', '', 'ğŸ” No directories match your filters.');
        msg.style.gridColumn = '1 / -1';
        msg.style.textAlign = 'center';
        msg.style.color = 'var(--muted)';
        msg.style.padding = '40px 20px';
        grid.appendChild(msg);
      }
      
    } catch (error) {
      grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; color:var(--danger)">Error loading directories. Please refresh.</div>';
      ErrorHandler.handle(error, 'UI.renderAll');
    }
  },
  
  async renderFeatured() {
    const featured = document.getElementById('featured');
    if (!featured) return;
    
    const picks = DIRS.filter(p => 
      /(^|\/)(sentinel|prime-sentinel|sentinelarc|peace|peace\-lab|peace\-ripple\-tracker|peacerippletracker|impacttracker|corruption|anti-corruption\.html)\b/i.test(p)
    );
    
    featured.innerHTML = '';
    const unique = [...new Set(picks)].sort();
    
    for (const path of unique) {
      const card = await this.createCard(path);
      featured.appendChild(card);
    }
  }
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Event Handlers & UI Controls
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function initControls() {
  const search = document.getElementById('search');
  const filter = document.getElementById('filter');
  const favBtn = document.getElementById('favoritesBtn');
  const enhancedBtn = document.getElementById('enhancedBtn');
  const aiEnhanceBtn = document.getElementById('aiEnhanceBtn');
  const resetBtn = document.getElementById('resetProg');
  
  const getFilters = () => ({
    filterTag: filter?.value || '',
    searchTerm: search?.value || '',
    onlyFavs: favBtn?.classList.contains('on'),
    onlyEnhanced: enhancedBtn?.classList.contains('on')
  });
  
  const updateUI = () => {
    const filters = getFilters();
    UI.renderAll(filters.filterTag, filters.searchTerm, filters.onlyFavs, filters.onlyEnhanced);
  };
  
  if (search) {
    search.addEventListener('input', updateUI);
  }
  
  if (filter) {
    filter.addEventListener('change', updateUI);
  }
  
  if (favBtn) {
    favBtn.addEventListener('click', () => {
      favBtn.classList.toggle('on');
      favBtn.textContent = favBtn.classList.contains('on') ? 'â˜… Favorites (On)' : 'â˜… Favorites';
      updateUI();
    });
  }
  
  if (enhancedBtn) {
    enhancedBtn.addEventListener('click', () => {
      enhancedBtn.classList.toggle('on');
      enhancedBtn.textContent = enhancedBtn.classList.contains('on') ? 'âœ¨ Enhanced (On)' : 'âœ¨ Enhanced Only';
      updateUI();
    });
  }
  
  if (aiEnhanceBtn) {
    aiEnhanceBtn.addEventListener('click', () => AI.enhanceAll());
  }
  
  if (resetBtn) {
    resetBtn.addEventListener('click', async () => {
      if (!confirm('âš ï¸ Reset ALL progress and AI enhancements? This cannot be undone.')) return;
      
      try {
        await DB.clear(CONFIG.STORE_NAMES.DIRECTORIES);
        await DB.clear(CONFIG.STORE_NAMES.USER_DATA);
        
        State.xp = 0;
        State.lvl = 1;
        State.favs = {};
        
        State.renderHUD();
        await UI.renderFeatured();
        await UI.renderAll();
        
        Toast.show('Progress reset successfully', 'success');
      } catch (error) {
        ErrorHandler.handle(error, 'resetProgress');
      }
    });
  }
  
  // AI Panel controls
  const aiFab = document.getElementById('aiFab');
  const aiPanel = document.getElementById('aiPanel');
  const aiClose = document.getElementById('aiClose');
  const aiInput = document.getElementById('aiInput');
  const aiSend = document.getElementById('aiSend');
  const aiStatus = document.getElementById('aiStatus');
  
  if (aiFab && aiPanel) {
    aiFab.addEventListener('click', () => {
      aiPanel.classList.add('open');
      aiFab.classList.add('hidden');
      if (aiInput) aiInput.focus();
    });
  }
  
  if (aiClose && aiPanel && aiFab) {
    aiClose.addEventListener('click', () => {
      aiPanel.classList.remove('open');
      aiFab.classList.remove('hidden');
    });
  }
  
  if (aiStatus && aiPanel && aiFab) {
    aiStatus.addEventListener('click', () => {
      aiPanel.classList.add('open');
      aiFab.classList.add('hidden');
    });
  }
  
  const sendMessage = () => {
    const message = aiInput?.value.trim();
    if (!message) return;
    
    AI.chat(message);
    if (aiInput) aiInput.value = '';
  };
  
  if (aiSend) {
    aiSend.addEventListener('click', sendMessage);
  }
  
  if (aiInput) {
    aiInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Service Worker (Offline Support)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function registerServiceWorker() {
  if (!('serviceWorker' in navigator)) return;
  
  const sw = `
    const CACHE_NAME = 'galactic-directory-v2';
    
    self.addEventListener('install', e => {
      self.skipWaiting();
    });
    
    self.addEventListener('activate', e => {
      self.clients.claim();
    });
    
    self.addEventListener('fetch', e => {
      // Passthrough - no caching yet
      // FUTURE: Implement cache-first strategy for static assets
    });
  `;
  
  const blob = new Blob([sw], {type: 'text/javascript'});
  const url = URL.createObjectURL(blob);
  
  navigator.serviceWorker.register(url).catch(err => {
    console.warn('Service Worker registration failed:', err);
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SECTION: Application Initialization
   PURPOSE: Bootstrap the entire application with error recovery
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function init() {
  try {
    console.log('%cğŸ›¡ï¸ Galactic Directory', 'font-size:18px; color:#65b3ff; font-weight:bold');
    console.log('%cAI-Enhanced Â· Local-First Â· Zero-Harm', 'color:#4ee0a1');
    console.log('%cInitializing IndexedDB and AI systems...', 'color:#9bb0cc');
    
    // Initialize database
    await DB.open();
    
    // Load user state
    await State.load();
    State.renderHUD();
    
    // Initialize UI controls
    initControls();
    
    // Render directories
    await UI.renderFeatured();
    await UI.renderAll();
    
    // Register service worker
    registerServiceWorker();
    
    // Show welcome message for new users
    if (State.lvl === 1 && State.xp === 0) {
      setTimeout(() => {
        Toast.show('Welcome! Click "ğŸ¤– AI Enhance All" to let the AI improve directory metadata.', 'info', 8000);
      }, 1000);
    }
    
    console.log('%câœ“ Initialization complete', 'color:#4ade80; font-weight:bold');
    
  } catch (error) {
    console.error('Fatal initialization error:', error);
    Toast.show('Failed to initialize application. Please refresh the page.', 'error');
    ErrorHandler.handle(error, 'init');
  }
}

// Start application when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</script>

</body>
</html>